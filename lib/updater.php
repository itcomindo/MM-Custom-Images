<?php

/**
 * Generic Plugin Updater Library
 *
 * This file is a generic library for handling plugin updates from a private server.
 * DO NOT EDIT THIS FILE.
 *
 * @version 1.1.0
 */

defined('ABSPATH') || die('No script kiddies please!');

// Wrap the entire class definition in a class_exists check
// This prevents fatal errors if another plugin uses the same library.
if (! class_exists('My_Plugin_Updater_Library')) :

    class My_Plugin_Updater_Library
    {
        private $file;
        private $plugin_slug;
        private $api_url;
        private $current_version;
        private static $update_just_completed = false;

        public function __construct($file, $plugin_slug, $api_url)
        {
            $this->file            = $file;
            $this->plugin_slug     = $plugin_slug;
            $this->api_url         = $api_url;

            // Get the version from the main plugin file's data
            $plugin_data           = get_plugin_data($this->file);
            $this->current_version = $plugin_data['Version'];

            // Register hooks
            add_filter('pre_set_site_transient_update_plugins', [$this, 'check_for_updates']);
            add_filter('plugins_api', [$this, 'plugin_popup_info'], 10, 3);
            add_action('upgrader_process_complete', [$this, 'after_update'], 10, 2);
            add_filter('plugin_auto_update_setting_html', [$this, 'add_auto_update_link'], 10, 3);
        }

        /**
         * The activation hook callback.
         * Moved inside the class as a static method to avoid function name conflicts.
         */
        public static function on_activation()
        {
            delete_site_transient('update_plugins');
        }

        public function check_for_updates($transient)
        {
            if (self::$update_just_completed) {
                return $transient;
            }

            if (empty($transient->checked)) {
                return $transient;
            }

            $remote_info = $this->get_remote_info();

            if ($remote_info && version_compare($this->current_version, $remote_info->version, '<')) {
                $obj = new stdClass();
                $obj->slug = $this->plugin_slug;
                $obj->new_version = $remote_info->version;
                $obj->url = $remote_info->homepage;
                $obj->package = $remote_info->download_url;
                $obj->icons = ['1x' => $remote_info->banners->low ?? '', '2x' => $remote_info->banners->high ?? ''];
                $obj->banners = ['low' => $remote_info->banners->low ?? '', 'high' => $remote_info->banners->high ?? ''];
                $obj->tested = $remote_info->tested;
                $obj->requires = $remote_info->requires;
                $obj->requires_php = $remote_info->requires_php;
                $obj->autoupdate_supported = true;
                $transient->response[plugin_basename($this->file)] = $obj;
            }

            return $transient;
        }

        public function after_update($upgrader_object, $options)
        {
            if ($options['action'] == 'update' && $options['type'] === 'plugin') {
                foreach ($options['plugins'] as $plugin) {
                    if ($plugin === plugin_basename($this->file)) {
                        delete_site_transient('update_plugins');
                        self::$update_just_completed = true;
                        break;
                    }
                }
            }
        }

        public function plugin_popup_info($result, $action, $args)
        {
            if ('plugin_information' !== $action || ! isset($args->slug) || $args->slug !== $this->plugin_slug) {
                return $result;
            }

            $remote_info = $this->get_remote_info();

            if ($remote_info) {
                $result = new stdClass();
                $result->name = $remote_info->name;
                $result->slug = $remote_info->slug;
                $result->version = $remote_info->version;
                $result->author = $remote_info->author;
                $result->author_profile = $remote_info->author_profile;
                $result->last_updated = $remote_info->last_updated;
                $result->homepage = $remote_info->homepage;
                $result->download_link = $remote_info->download_url;
                $result->sections = (array) $remote_info->sections;
                $result->banners = (array) $remote_info->banners;
                $result->requires = $remote_info->requires;
                $result->tested = $remote_info->tested;
                $result->requires_php = $remote_info->requires_php;
            }

            return $result;
        }

        public function add_auto_update_link($html, $plugin_file, $plugin_data)
        {
            if (plugin_basename($this->file) === $plugin_file) {
                $auto_updates = (array) get_site_option('auto_update_plugins', []);

                $text = in_array($plugin_file, $auto_updates) ? __('Disable auto-updates') : __('Enable auto-updates');
                $action = in_array($plugin_file, $auto_updates) ? 'disable' : 'enable';

                $url = wp_nonce_url(
                    add_query_arg(['action' => "{$action}-auto-update", 'plugin' => $plugin_file], 'plugins.php'),
                    "{$action}-auto-update__{$plugin_file}"
                );

                $html = sprintf('<a href="%s" class="toggle-auto-update" data-plugin="%s" data-action="%s">', $url, $plugin_file, $action);
                $html .= sprintf('<span class="label">%s</span>', $text);
                $html .= '</a>';
            }
            return $html;
        }

        private function get_remote_info()
        {
            $request = wp_remote_get($this->api_url);
            if (! is_wp_error($request) && wp_remote_retrieve_response_code($request) === 200) {
                return json_decode(wp_remote_retrieve_body($request));
            }
            return false;
        }
    }

endif; // End if class_exists